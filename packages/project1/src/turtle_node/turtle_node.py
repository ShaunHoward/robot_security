#!/usr/bin/env python

import rospy
import tf
import math
import random
from geometry_msgs.msg import PoseStamped, Twist
from nav_msgs.msg import Odometry, OccupancyGrid
from particle_filter import particle_filter_node as pf
import helpers as h

class GridMap(object):
    last_goal = None

    def __init__(self, grid, goal):
        self.grid = grid
        self.goal = goal
        self.width = len(grid[0])
        self.height = len(grid)

    def random_place(self):
        x = random.uniform(0, self.width)
        y = random.uniform(0, self.height)
        return x, y

    def random_free_place(self):
        """
        Return a new random point that is open on the map.
        :return: random point that is free on the map
        """
        while True:
            x, y = self.random_place()
            if self.is_free(x, y):
                return x, y

    def is_free(self, x, y):
        if not self.is_in(x, y):
            return False

        yy = self.height - int(y) - 1
        xx = int(x)
        return self.grid[yy][xx] == 0

    def is_in(self, x, y):
        if x < 0 or y < 0 or x > self.width or y > self.height:
            return False
        return True

    def dist_to_goal(self, x, y):
        if self.goal is not None or self.last_goal is not None:
            return math.sqrt((self.goal[0] - x) ** 2 + (self.goal[1] - y) ** 2)
        return 1000000000


def transform_map_to_occupancy_grid(map_data, height, width):
    grid = []
    curr_place = 0
    for i in range(height):
        curr_row = []
        for j in range(width):
            curr_row.append(map_data.data[curr_place])
            curr_place += 1
        grid.append(curr_row)
    return grid


def pose2tuple(pose):
    x = pose.position.x
    y = pose.position.y
    quaternion = (
        pose.orientation.x,
        pose.orientation.y,
        pose.orientation.z,
        pose.orientation.w)
    h = tf.transformations.euler_from_quaternion(quaternion)[2]
    return x, y, h


class Point(object):
    x = 0
    y = 0
    h = 0

    def __init__(self, x, y, h):
        self.x = x
        self.y = y
        self.h = h


class TurtleBot(Point):
    # ros stuff
    my_odom = None
    my_filtered_odom = None
    cmd_vel_pub = None
    map_subscriber = None
    goal_subscriber = None

    # generated by filter
    my_filtered_odom_pos = (0, 0, 0)

    # generated by odom sensor
    my_odom_pos = (0, 0, 0)

    # quaternion to euler transformer
    header_transformer = None

    ros_rate = 10

    grid_map = None

    goal = None

    filter_started = False

    def __init__(self, xi=0, yi=0, hi=0, speed=0.2, rate=10, id=0):
        super(TurtleBot, self).__init__(xi, yi, hi)
        self.speed = speed
        self.id = id
        self.id_str = '/turtlebot' + str(id)

        # lastly, start the robot
        self.start(id, rate)

    def start(self, id, rate=10):
        # initialize
        rospy.init_node('TurtleBot' + str(id), anonymous=False)
        self.ros_rate = rospy.Rate(rate)
        rospy.loginfo('Use ctrl-c to stop TurtleBot')
        rospy.on_shutdown(self.stop)

        # subscribe to robot odom
        self.my_odom = rospy.Subscriber(self.id_str + '/odom', Odometry, self.odom_callback)

        # subscribe to filtered odom
        self.my_filtered_odom = rospy.Subscriber(self.id_str + '/odometry/filtered', Odometry,
                                                 self.filtered_odom_callback)

        # publisher to command movement from TurtleBot, + str(id)
        self.cmd_vel_pub = rospy.Publisher(self.id_str + '/cmd_vel_mux/input/navi', Twist, queue_size=10)

        # self.map_subscriber = rospy.Subscriber('/map', OccupancyGrid, callback=self.map_callback)
        # self.goal_subscriber = rospy.Subscriber('/move_base_simple/goal', PoseStamped, callback=self.goal_callback)

    # called by ros on shutdown
    def stop(self):
        rospy.loginfo(''.join(["TurtleBot", str(self.id), " has stopped"]))
        self.cmd_vel_pub.publish(Twist())
        # make sure robot gets the message
        rospy.sleep(1)
        return

    def move_on_x(self, amount, lower_bound=1, upper_bound=5):
        goal_x = self.x + amount
        print
        within_bounds = h.check_bounds(goal_x, lower_bound, upper_bound)
        if within_bounds:
            move_cmd = Twist()
            if amount < 0:
                move_cmd.linear.x = -self.speed
                dist_to_goal = -amount
            else:
                move_cmd.linear.x = self.speed
                dist_to_goal = amount
            rospy.loginfo('Robot is heading to destination x: ' + str(goal_x))
            prev_time = h.get_curr_time()
            tot_dist_traveled = 0
            while dist_to_goal > 0.1:
                self.cmd_vel_pub.publish(move_cmd)
                self.ros_rate.sleep()
                curr_time = h.get_curr_time()
                diff = curr_time - prev_time
                dist_traveled = self.speed * diff
                tot_dist_traveled += dist_traveled
                dist_to_goal -= dist_traveled
                prev_time = curr_time
            if amount < 0:
                self.x -= tot_dist_traveled
            else:
                self.x += tot_dist_traveled
            rospy.loginfo('Robot has reached its destination x of ' + str(goal_x))
            self.stop()
        else:
            rospy.loginfo('Goal received outside of robot bounds.')

    def odom_callback(self, msg):
        (x, y, h) = pose2tuple(msg.pose.pose)
        self.my_odom_pos = (x, y, h)
        # rospy.loginfo('unfiltered robot x, y, header: %f %f %f' % (x, y, h))

    def filtered_odom_callback(self, msg):
        (x, y, h) = pose2tuple(msg.pose.pose)
        self.my_filtered_odom_pos = (x, y, h)
        # rospy.loginfo('filtered robot x, y, header: %f %f %f' % (self.x, self.y, self.h))

    def map_callback(self, data):
        # only construct map if grid map is none
        if self.grid_map is None:
            # print data
            map = transform_map_to_occupancy_grid(data, data.info.height, data.info.width)
            grid_map = GridMap(map, self.goal)
            self.grid_map = grid_map

    def goal_callback(self, data):
        rospy.loginfo("goal acquired: %f, %f" % (data.pose.position.x, data.pose.position.y))
        self.goal = pose2tuple(data.pose)
        self.grid_map.goal = self.goal
        if self.goal is not None:
            self.grid_map.last_goal = self.goal

    # def move(self, speed, h=90):
    #     """Move turtle bot discretely"""
    #     h = self.h
    #     r = math.radians(h)
    #     dx = math.sin(r) * self.speed
    #     dy = math.cos(r) * self.speed
    #     self.move_by(dx, dy)
    #     self.steps += 1
    #
    # def move_by(self, x, y):
    #     move_cmd = Twist()
    #     move_cmd.linear.x = self.speed
    #
    #     goal_x = self.x + x
    #     goal_y = self.y + y
    #
    #     # my_odom_pos updated by odom callback
    #     curr_diff_x = abs(goal_x - self.my_odom_pos[0])
    #     curr_diff_y = abs(goal_y - self.my_odom_pos[1])
    #     curr_header = self.h
    #     # move until the closeness has met a certain threshold
    #     while curr_diff_x <= x or curr_diff_y <= y:
    #         self.cmd_vel_pub.publish(move_cmd)
    #         # sleep to let robot process msg
    #         self.ros_rate.sleep()
    #         curr_diff_x = abs(goal_x - self.my_odom_pos[0])
    #         curr_diff_y = abs(goal_y - self.my_odom_pos[1])
    #
    #     # stop robot
    #     self.cmd_vel_pub.publish(Twist())
    #
    #     # update coordinates in grid
    #     self.x += x
    #     self.y += y
