__author__ = 'shaun'

import rospy
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
import math
import random
from particle_filter import particle_filter as pf
from romdp import utils


class GridMap(object):

    def __init__(self, grid, goal_states):
        self.grid = grid
        self.goal_states = goal_states
        self.width = len(grid[0])
        self.height = len(grid)

    def closest_goal_and_dist(self, (x, y)):
        min = 1000000
        closest = None
        for goal in self.goal_states:
            dist = utils.distance((x, y), goal)
            if dist < min:
                min = dist
                closest = goal
        return closest, min

    def random_place(self):
        x = random.uniform(0, self.width)
        y = random.uniform(0, self.height)
        return x, y

    def random_free_place(self):
        """
        Return a new random point that is open on the map.
        :return: random point that is free on the map
        """
        while True:
            x, y = self.random_place()
            if self.is_free(x, y):
                return x, y

    def is_free(self, x, y):
        if not self.is_in(x, y):
            return False

        yy = self.height - int(y) - 1
        xx = int(x)
        return self.grid[yy][xx] == 0

    def is_in(self, x, y):
        if x < 0 or y < 0 or x > self.width or y > self.height:
            return False
        return True


class TurtleBot(pf.Particle):
    # ros stuff
    my_odom = None
    cmd_vel_pub = None

    # generated by sensor
    my_odom_pos = tuple

    # generated by romdp and particle filter
    my_belief_pos = dict()

    def __init__(self, xi=0, yi=0, hi=90, speed=0.2, rate=10, grid_map=None, id=0):
        super(TurtleBot, self).__init__(xi, yi, heading=hi)
        self.grid_map = grid_map
        self.speed = speed
        self.steps = 0
        self.ros_rate = rospy.Rate(rate)
        self.id = id

        # lastly, start the robot
        self.start(id)

    def start(self, id):
        # initialize
        rospy.init_node('TurtleBot' + id, anonymous=False)
        rospy.loginfo('Use ctrl-c to stop TurtleBot')
        rospy.on_shutdown(self.stop)

        # subscribe to robot odom
        self.my_odom = rospy.Subscriber('/odom', Odometry, self.odom_callback)

        # publisher to command movement from TurtleBot
        self.cmd_vel_pub = rospy.Publisher('cmd_vel_mux/input/navi' + id, Twist, queue_size=10)

    # called by ros on shutdown
    def stop(self):
        rospy.loginfo(''.join(["TurtleBot", str(self.id), " has stopped"]))
        self.cmd_vel_pub.publish(Twist())
        # make sure robot gets the message
        rospy.sleep(1)

    def odom_callback(self, msg):
        print msg.pose.pose
        x = msg.pose.pose.Point.x
        y = msg.pose.pose.Point.y
        z = msg.pose.pose.Point.z
        self.my_odom_pos = (x, y, z)

    def move(self, speed):
        """Move turtle bot discretely"""
        h = self.h
        r = math.radians(h)
        dx = math.sin(r) * self.speed
        dy = math.cos(r) * self.speed
        self.move_by(dx, dy)
        self.steps += 1

    def move_by(self, x, y):
        move_cmd = Twist()
        move_cmd.linear.x = self.speed
        move_cmd.angular.z = 0

        goal_x = self.x + x
        goal_y = self.y + y

        # my_odom_pos updated by odom callback
        curr_diff_x = abs(goal_x - self.my_odom_pos[0])
        curr_diff_y = abs(goal_y - self.my_odom_pos[1])

        # move until the closeness has met a certain threshold
        while curr_diff_x <= x and curr_diff_y <= y:
            self.cmd_vel_pub.publish(move_cmd)
            # sleep to let robot process msg
            self.ros_rate.sleep(1)
            curr_diff_x = abs(goal_x - self.my_odom_pos[0])
            curr_diff_y = abs(goal_y - self.my_odom_pos[1])

        # stop robot
        self.cmd_vel_pub.publish(Twist())

        # update coordinates in grid
        self.x += x
        self.y += y
        self.h = self.my_odom_pos[2]
